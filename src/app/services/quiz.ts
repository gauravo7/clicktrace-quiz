import { inject, Injectable } from '@angular/core';
import { Database, list } from '@angular/fire/database';
import { DatabaseReference, push, ref, remove, update } from '@firebase/database';
import { map, Observable } from 'rxjs';


export interface TodoItem {
  id?: string; // ID is the RTDB key, required for update/delete
  task: string;
  completed: boolean;
}

@Injectable({
  providedIn: 'root'
})

export class Quiz {

   // Use the new functional inject() for services
  private db: Database = inject(Database);
  private todosRef = ref(this.db, 'todos'); // Reference to the 'todos' path

  // 1. Read (R) - Returns an Observable of the collection
  getTodos(): Observable<TodoItem[]> {
    // list() reads the data as a list of snapshots
    return list(this.todosRef).pipe(
      // Map the array of DataSnapshot to an array of TodoItem objects
      map(changes => {
        return changes.map((c:any) => {
          // c.key is the unique ID generated by push()
          const item = c.snapshot.val() as Omit<TodoItem, 'id'>;
          return { id: c.key, ...item } as TodoItem;
        });
      })
    );
  }

  // 2. Create (C) - Adds a new document
addTodo(task: string): Promise<void> {
  if (!task.trim()) {
    return Promise.reject(new Error("Task cannot be empty"));
  }
  // Step 1: Create new item WITHOUT id
  const newItem: Omit<TodoItem, 'id'> = { task, completed: false };
  return push(this.todosRef, newItem) // push generates a unique key
    .then((ref) => {
      const newId = ref.key;
      if (!newId) {
        throw new Error("Failed to generate a key for the new todo item.");
      }
      // Step 2: Update the same item to include 'id'
      return update(ref, { id: newId });
    });
}


  // 3. Update (U) - Updates an existing document
  updateTodo(todo: TodoItem): Promise<void> {
    if (!todo.id) return Promise.reject("Todo ID is required for update.");

    // Get a reference to the specific item using its ID
    const itemRef = ref(this.db, `todos/${todo.id}`);

    // Destructure to avoid sending the 'id' field to the database
    const { id, ...data } = todo;

    // update() patches the data at the specified location
    return update(itemRef, data);
  }

  // 4. Delete (D) - Deletes a document by ID
  deleteTodo(id: string): Promise<void> {
    const itemRef = ref(this.db, `todos/${id}`);
    // remove() deletes the node at the specified location
    return remove(itemRef);
  }
}
