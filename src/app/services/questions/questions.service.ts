import { inject, Injectable } from '@angular/core';
import { Database, get, list, push, ref, remove, set, update } from '@angular/fire/database';
import { map, Observable } from 'rxjs';
import { TodoItem } from '../quiz';

@Injectable({
  providedIn: 'root'
})
export class QuestionsService {

  private db: Database = inject(Database);
  private todosRef = ref(this.db, 'questions'); // Reference to the 'todos' path
  private liveRef = ref(this.db, 'live');


  addQuestion(questionObj:any): Promise<void> {
    const newItem: Omit<any, 'id'> = { ...questionObj };
    return push(this.todosRef, newItem) // push generates a unique key
      .then((ref) => {
        const newId = ref.key;
        if (!newId) {
          throw new Error("Failed to generate a key for the new todo item.");
        }
        return update(ref, { id: newId });
      });
  }


  getQuestions(): Observable<any[]> {
    return list(this.todosRef).pipe(
      map(changes => {
        return changes.map((c:any) => {
          const item = c.snapshot.val() as Omit<any, 'id'>;
          return { id: c.key, ...item } as any;
        });
      })
    );
  }


  updateQuestion(todo: any): Promise<void> {
      if (!todo.id) return Promise.reject("Todo ID is required for update.");

      // Get a reference to the specific item using its ID
      const itemRef = ref(this.db, `questions/${todo.id}`);

      // Destructure to avoid sending the 'id' field to the database
      const { id, ...data } = todo;

      // update() patches the data at the specified location
      return update(itemRef, data);
    }


    deleteQuestion(id: any): Promise<void> {
        const itemRef = ref(this.db, `questions/${id}`);
        // remove() deletes the node at the specified location
        return remove(itemRef);
    }

    // New method to set live question
      async setLiveQuestion(question: any): Promise<void> {
        const liveRef = ref(this.db, 'live');
        const backupRef = ref(this.db, 'backupAttempts');

        const liveSnapshot = await get(liveRef);
        const currentLive = liveSnapshot.val();

        if (currentLive) {
          // Save current live question to backup
          await push(backupRef, {
            ...currentLive,
            movedAt: Date.now(), // optional timestamp
            movedDate:new Date().toISOString()
          });
        }


        await remove(liveRef);

        const liveQuestion = {
          question: {
            ...question,
            isStart: false,
            isEnd: false,
            leaderboard: [],
            addedAt: Date.now(),
          }
        };

        return set(liveRef, liveQuestion);
    }

  async stopLiveQuestion(): Promise<void> {
    const db = this.db;
    const liveRef = ref(db, 'live');
    const backupRef = ref(db, 'backupAttempts');

    try {
      // 1️⃣ Get current live question
      const liveSnapshot = await get(liveRef);
      const currentLive = liveSnapshot.val();

      if (currentLive) {
        // Save current live question to backup
        await push(backupRef, {
          ...currentLive,
          movedAt: Date.now() // optional timestamp
        });
      }
      await remove(liveRef);

    } catch (err) {
      console.error(' Error setting live question', err);
    }
}





    getLiveQuestion(): Observable<any[]> {

        return list(this.liveRef).pipe(

          map(changes => {
            return changes.map((c:any) => {
              // c.key is the unique ID generated by push()
              const item = c.snapshot.val()
              return item  as any;
            });
          })
        );
      }

    saveAnswertoLeaderBoard(user: any): Promise<void> {
           const leaderboardRef = ref(this.db, 'live/question/leaderboard');
            return push(leaderboardRef, user).then(() => {}
          );
      }
    showOptions(id:any) {
       const liveRef = ref(this.db, `live/question`);
       return update(liveRef,{isStart:true, addedAt: Date.now()})
    }

}
